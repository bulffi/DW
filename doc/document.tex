\documentclass{ctexrep}
\bibliographystyle{plain}
\CTEXsetup[format={\Large\bfseries}]{section}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{url}
\usepackage{supertabular}
\usepackage{float}
\usepackage{multicol}
\usepackage[a4paper, inner=2.5cm, outer=4cm, top=2cm,bottom=3cm, bindingoffset=1cm]{geometry}
\usepackage{tabularx, makecell, multirow,ulem}
\usepackage{listings,xcolor}
\lstset{
	rulesepcolor= \color{gray}, %代码块边框颜色
	breaklines=true,  %代码过长则换行
	numbers=left, %行号在左侧显示
	numberstyle= \small,%行号字体
	keywordstyle= \color{red},%关键字颜色
	commentstyle=\color{gray}, %注释颜色
	frame=shadowbox%用方框框住代码块
}
\usepackage[bookmarks=true,colorlinks,breaklinks]{hyperref}
\title{\textbf{数据仓库项目报告}}
\author{罗浩1752547，李一珉1752882，\\张子健1752894，田云龙1752248}
\date{}
\begin{document}
	\maketitle
	\begin{abstract}
		本报告涉及2019-2020秋季学期数据仓库课程项目的ETL、Instance Matching、数据存储与查询等三个方面。主要介绍了三种（关系型、分布式以及图数据库）存储模型在本项目中的使用情况，它们对应的逻辑与物理模型以及相应的优化和适用范围。
	\end{abstract}
	\tableofcontents
	
	\chapter{数据获取}
	根据课程要求，我们的数据分别来自于 Snap 文本文件以及 Amazon 的网站，下面分别描述针对这两种数据我们的处理方式。
	\section{评论文本文件导入}
	由于文本文件较大，我们采用了自己写的Python脚本来进行导入，操作处理十分简单。建立相应的类，然后从文件中一行一行的读取数据，根据该行冒号之前的内容来判断该行是在处理哪个属性，并对对象的相应属性赋值，最后使用pyodbc将其存入SQL Server\footnote{我们在后续的项目中没有再使用 SQL Server 数据库，将其导入SQL Server 只是作为暂时的存储}数据库中。随本文档附带的脚本文件中包含有本程序，因此不再进行描述。
	\section{网页数据爬取}
	在上一步骤的基础上，我们使用 \begin{lstlisting}[language=sql]
select distinct product_id
from movie_review
	\end{lstlisting}
	就可以获取到所有有待获取信息的电影的ID，将其保存到 csv 文件中，我们就确立了获取数据的目标。为了较为轻松的获取数据，我们使用了最著名的Python网络爬虫库Scrapy（\url{https://scrapy.org/} 来进行爬虫。Scrapy的结构如下图所示。
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/scrapy_architecture_02}
		\caption{Scrapy结构}
		\label{fig:scrapyarchitecture02}
	\end{figure}
	Scrapy能够帮助我们完成发起请求、获取原始HTML文件、将文件递交给Spider进行数据抽取并最终将处理结果传递给流水线进行处理。我们需要主要要写的就是 Spider、PipeLines以及Middleware。下面分别对这三种结构进行描述
	\subsection{Spider}
	Spider 是爬虫的核心，请求的发起以及对HTML文件中数据的抽取都由它来负责。在我们的项目中，请求的发起就是根据上述生成的csv文件来获取完整路径名来进行的。下载的HTML文件会作为参数传递到下述的函数中\begin{lstlisting}[language=python]
 def parse(self, response, **kwargs):
	\end{lstlisting}
	在这个函数中，我们对response做xpath的解析，从而抽取数据。下面给出提取演员时所使用的xpath表达式作为例子\begin{lstlisting}[language=python]
actors = response.xpath(
   '//*[@id="detail-bullets"]/table//tr/td/div/ul/li[{}]/a//text()'.format(i)).extract()
actors = ', '.join(actors)
	\end{lstlisting}
	其他变量的处理也是类似的，不再赘述 \footnote{我们所上交的文件中的xpath现在未必可以正确的提取出数据来，因为Amazon网站有时会修改元素的类名，在类名之前添加随机字符串。例如抽取电影类型的表达式'(//div[@class="\_2vWb4y dv-dp-node-meta-info"]//dl)[1]/dd/a/text()'中的'\_2vWb4y就是我们第二次爬虫的时候修改的（大概在2019年11月），第一次我们爬虫的时候该字段是‘\_3RXp\_N’（大概在2019年国庆节前）。尽管如此，这种处理方式仍是成立的}。
	
	同样值得注意的是，Amazon的电影信息所处在的网页格式并不是唯一的，事实上有两种，分别如下图所示
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/old}
		\caption{老版网页}
		\label{fig:old}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/new}
		\caption{新版网页}
		\label{fig:new}
	\end{figure}
	而我们是根据新版网页中的那个 Terms 来进行判断（用红色圈出）的。如果有这个 Terms，我们就会使用针对新版网页写的脚本进行提取，而老版本则使用另外的脚本来提取。
	
	完成相应值的抽取之后，我们将他们都集中到一个对象中，然后使用 yield 将该对象返回，该对象在后面会被送给 Item Pileline 进行处理。大致代码如下：\begin{lstlisting}
oader.add_value('movie_id', movie_id)
loader.add_value('actors', actors)
loader.add_value('directors', directors)
loader.add_value('release_date', release_date)
loader.add_value('movie_type', movie_type)
loader.add_value('movie_version', movie_version)
loader.add_value('movie_title', movie_title)
# print(loader.load_item())
yield loader.load_item()
	\end{lstlisting}
	\subsection{Pipeline}
	在上述的Spider返回对象之后，Pipeline将会收到这些对象，并且在这里对这些对象进行存储或者处理，然后再返回Item对象，以便其他的Pipeline元素处理。在我们的项目中，我们只需要一个pipeline对象来将爬出的数据存储到数据库里就可以了。代码是简明的，大致如下：\begin{lstlisting}
self.cursor.execute("""
  insert into movie_info(movie_id, movie_title, directors, release_date, movie_type, movie_version, actors)
  values (?,?,?,?,?,?,?)
  """, [
    item.get('movie_id')[0], item.get('movie_title')[0], item.get('directors')[0],
    item.get('release_date')[0],
    item.get('movie_type')[0], item.get('movie_version')[0], item.get('actors')[0]
])
self.cnxn.commit()
	\end{lstlisting}
	\subsection{Middleware}
	Middleware主要是在请求发送之前可以对请求的参数进行加工。在我们的项目中，我们主要的需求是设置网络代理。由于需要爬出的电影有25万条，要想在合理的时间之内完成这个项目，爬取的速度必须要快，我们实际使用了百多个线程同时下载。在这种情况下，Amazon将会很快的封锁我们的IP，使得我们无法再继续访问（或者是要求用户来填写一些验证码，需要图像识别）。为了方便起见，我们使用了多贝云动态转发http隧道（\url{http://www.dobel.cn/act/https_pro/index.html}）,我们将请求发送给多贝云服务器，然后由它来转发，大致原理如下：\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/product_desc}
		\caption{多贝云代理}
		\label{fig:productdesc}
	\end{figure}
	
	在具体开始爬虫的时候，我们使用两台电脑共同运行爬虫程序，它们通过上文所述的 pipeline 向同一个数据库中写入爬出的电影数据，从而尽可能的达到最高的请求速度。实际爬虫的速度波动较大，好的时候可以到达100多部电影每分钟，差的时候只有40。下图是我们购买的服务的截图\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/proxy_pay}
		\caption{代理服务}
		\label{fig:proxypay}
	\end{figure}
	可以看到，我们事实上进行了两次爬虫，分别处在刚刚布置这项作业时以及项目正式开始时。第二次其实收获不大，主要是查漏补缺，为数据预处理做好准备。而我们所说的 middle 类正是做这样的代理设置，配置代码如下\begin{lstlisting}[language=python]
def process_request(self, request, spider):
  # 设置代理服务器域名和端口，注意，具体的域名要依据据开通账号时分配的而定
  request.meta['proxy'] = "http-proxy-t3.dobel.cn:9180"
  # 设置账号密码
  proxy_user_pass = "QAZXSW7EBELQS70:sgThtJkQ"
  # setup basic authentication for the proxy
  encoded_user_pass = "Basic " + base64.urlsafe_b64encode(bytes((proxy_user_pass), "ascii")).decode("utf8")
  request.headers['Proxy-Authorization'] = encoded_user_pass
  request.meta['max_retry_times'] = 10
	\end{lstlisting}
	\section{数据获取结果}
	成功获取了所有的评论文本数据以及绝大部分的电影数据。但是由于有的电影链接都已经失效，总共获得了\textbf{252382}行电影信息。
	
	\chapter{数据预处理}
	我们将上一步骤的结果输出为csv文件，就具有了有关电影的信息。为了处理数据中的冗余情况，我们对于数据中的重复项进行了合并，下面分别针对总体结构、判重标准以及合并策略三方面进行描述。
	\section{总体结构}
	由于在课程中朱老师特别强调重视可拓展性多于匹配的准确性，因此我们的处理方式对可拓展性进行了特别的重视，我们采用的是Hadoop的MapReduce模型来进行Instance Matching，以此获得在我们现有知识范围中最佳的可拓展性的同时保持对数据进行较为细粒度处理的可能。大致的处理流程如下图所示\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/maprecude}
		\caption{Map Reduce示意图}
		\label{fig:maprecude}
	\end{figure}
	
	我们考虑Map Reduce 模型的特征就可以发现如下两个明显特点：\begin{itemize}
		\item Map过程输出的 Key 就代表我们对\textbf{什么是相同电影} 的判断。因为具有相同Key的会被输入同一个Reduce中，这就自动的完成了相同电影的判断。
		\item Reduce 过程对某一个Key下所有Value的处理策略代表我们对\textbf{相同的电影应该怎么合并}的看法。因为它们最终会化为Reduce中的一次输出。
	\end{itemize}
在有了上面两个判断之后，我们再来进行下面的分别对判断标准和合并策略的描述就显得自然了（它们都已经简要的描述在了图 \ref{fig:maprecude} 上）。
	\section{判断标准}
	我们的判断标准非常简单，如果两个电影具有相同的名字和相同的导演（排序之后的导演列表），我们就认为这两个电影是同一部电影。这种判断足够简单，同时也具有一定的效力 \footnote{同一个导演不会拍两个不同的电影还给它们完全相同的名字。}。在这种策略的指导下，我们把思路实现为map函数。由于它还要处理从csv到对象的转化，过程稍显繁杂，下面只摘取最核心的部分进行展示。\begin{lstlisting}[language=java]
// info 是电影对象
List<String> directors = info.getDirector();
// 合并导演
Collections.sort(directors);
StringBuilder directorKey = new StringBuilder();
for (String dire : directors) {
  directorKey.append(dire).append(", ");
}
// lines[1]中是电影名
context.write(new Text(lines[1]+" "+directorKey.toString()), new Text(JSON.toJSONString(info)));
	\end{lstlisting}
	\section{合并策略}
	我们的合并策略也清晰简明。如下表所示\begin{longtable}{l|l}
		\hline
		条目 & 策略 \\
		\hline
		\hline
		时间 & 取最早日期\footnote{后面出来的同一部电影应该是翻拍} \\
		ID、类型、版本、演员 & 取并集\\
		\hline
		\caption{合并策略}
	\end{longtable}
		在这样的策略的指导下，我们可以完成合并，最终我们将电影信息写入Json文件，如下所示\begin{lstlisting}
context.write( NullWritable.get(),new Text(JSON.toJSONString(info)));
\end{lstlisting}
\section{合并结果}
在经过上述的合并之后，电影的数量从\textbf{252382}行下降到\textbf{195891}行，下降了22.3\%.
	
	\chapter{数据存储与查询}
	在完成数据的初步处理之后，我们按照要求将数据分别使用关系型数据库、分布式文件系统以及图数据库进行存储，下面分为三个部分分别对这三种存储方案下的存储模型、优化方案、实验数据以及对改种方案所适合的查询类型的判断的描述。
	\section{关系型数据库}
	\subsection{概述}
	为提高性能，本实验将数据存储在阿里云的十八万一个月的 MySQL 数据库集群中。该集群采用 MySQL 5.7 而非现在最新版的 MySQL 8.0，故本项目使用的SQL语法会有些许不一样。
	\subsection{逻辑模型}
	在从亚马逊网站上爬得电影基本信息以及下载了影评信息之后，我们得到了两个很大的实体，一个是电影基本信息实体，另一个是影评实体，如下图所示：
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/MySQL_ER1.png}
		\caption{两个原始实体}
		\label{fig:MySQL_ER1}
	\end{figure}
	但这两个实体不满足第一范式——原子性，因为它们有很多多值属性以及可再分属性：
	\begin{itemize}
        \item release\_date: 可再分属性，包含了年月日三个子属性
        \item directors: 多值属性，一个电影不只由一个导演执导
        \item actors: 多值属性，一个电影由众多演员出演
        \item types: 多值属性，一个电影有多种分类
        \item versions: 多值属性，一个电影有很多个版本
        \item helpfulness: 可再分属性，包含总评分人数和觉得有用的人数
    \end{itemize}
    故需要再给多值属性创建新的实体，并将可拆分属性拆分成多个属性。
    经过上述范化之后，模型仍有不足，原因如下：如果将上映时间简单的拆分成年月日的话，会存在冗余，因为一年最多只有 366 天，而我们却重复的存储了大量相同的月日信息。故我们只用建一个具有 366 行的 date 实体，并让 movie\_info 与某个人 date 建立联系。
    优化之后的E-R图如下：
    \begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/MySQL_ER2.png}
		\caption{优化版E-R图}
		\label{fig:MySQL_ER2}
	\end{figure}
	上图即为最终版逻辑模型，其满足第三范式，较为理想地减少了数据冗余。
	\subsection{物理模型及其优化方案}
	\subsubsection{初步模型} \label{mysql:1}
	初代物理模型一味追求降低数据冗余，直接将逻辑模型转化为数据库表结构，如下所示：
	\begin{itemize}
	    \item 电影信息主表
	        \begin{lstlisting}
create table movie_info
(
    movie_id integer primary key,
    movie_title varchar(500),
    year integer,
    date_key integer,
    constraint fact_date_fk foreign key (date_key) references date(date_key)
);
	        \end{lstlisting}
	    \item 上映日期表
	        \begin{lstlisting}
create table date
(
    date_key integer primary key,
    day integer,
    month integer
);
            \end{lstlisting}
        \item 导演表
            \begin{lstlisting}
create table movie_director
(
movie_id integer,
director_name varchar(500),
primary key (movie_id, director_name),
constraint director_fk foreign key(movie_id) references movie_info(movie_id)
);
            \end{lstlisting}
        \item 演员表
            \begin{lstlisting}
create table movie_actor
(
movie_id integer,
actor_name varchar(500),
is_lead boolean,
primary key (movie_id, actor_name),
constraint actor_fk foreign key(movie_id) references movie_info(movie_id)
);
            \end{lstlisting}
        \item 电影类型表
            \begin{lstlisting}
create table movie_type
(
movie_id integer,
type_name varchar(500),
primary key (movie_id, type_name),
constraint movie_type_fk foreign key(movie_id) references movie_info(movie_id)
);
            \end{lstlisting}
        \item 电影版本表
            \begin{lstlisting}
create table movie_version
(
movie_id integer,
version_name varchar(500),
primary key (movie_id, version_name),
constraint movie_version_fk foreign key(movie_id) references movie_info(movie_id)
);
            \end{lstlisting}
        \item 影评表
            \begin{lstlisting}
create table movie_review
(
productID integer,
userID varchar(500),
profileName varchar(500),
num_reader integer,
num_helpfulness integer,
score decimal(2,1),
time date,
summary varchar(10000),
text text,
primary key (productID, userID, score, time, summary),
constraint product_movie_fk foreign key (productID) references movie_info(movie_id)
);
            \end{lstlisting}
	\end{itemize}
    整体表结构如下图所示:
    \begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/MySQL_DB1.png}
		\caption{初代表结构}
		\label{fig:MySQL_DB1}
	\end{figure}
	在导入数据的过程中需要注意，由于我们做了Instance Matching，每一个电影的 movie\_id 可能不止一个。故我们重新给每一个电影赋予新id，并建立了一个临时的表并取名为 amazon\_movie\_id，其保存了新 id 与亚马逊网站上的 id 的映射关系：一个新 id 对应一到多个亚马逊 id。我们的其他表将不再使用亚马逊原来有的 id，而是全部使用我们自己新分配的 id。例如，在存储影评时，我们会查询 amazon\_movie\_id 表并将 productId 属性的值由亚马逊 id 转换成我们自己的id。
	\subsubsection{改进模型} \label{mysql:2}
    初代物理模型虽然尽可能地降低了数据冗余，但是查询效率非常不理想，我们从如下三个方面进行了优化：
    \begin{enumerate}
        \item \textbf{预存衍生数据}\\
        在按照上映时间查询电影时，用户并不总是按照年月日进行查询，而是还会涉及到季度与星期。对于初代物理模型，在执行此类查询时需要根据年月日当场计算季度与星期，这是十分耗时的。故我们决定预先计算好“季度”，“上下半年”与“星期”三个衍生数据，将其存入 movie\_info\_fact 表（即原先的 movie\_info 表）和 movie\_release\_date（即原先的 date 表）中。改进后的表结构如下图所示：
        \begin{itemize}
            \item 电影信息事实表
                \begin{lstlisting}
create table movie_info_fact
(
movie_id integer primary key,
movie_title varchar(500),
year integer,
weekday integer,
date_key integer,
constraint fact_date_fk foreign key (date_key) references movie_release_date(date_key)
);
                \end{lstlisting}
            \item 上映日期表
                \begin{lstlisting}
create table movie_release_date
(
date_key integer primary key,
date integer,
month integer,
year_quarter integer,
year_half integer
);
                \end{lstlisting}
        \end{itemize}
        用户时常按照平均评分查询电影。按照初代物理模型，在执行此类查询时需要将评论按 movie\_id 分好组，然后根据该分组中每一个影评的评分，分别计算每一个电影的平均评分，这是十分耗时的。故我们决定预先计算好每一个电影的评分以及评论人数，将其存在一个新表 precal\_movie\_avg\_score 中，其表结构如下所示：
        \begin{itemize}
            \item 电影平均评分表
                \begin{lstlisting}
create table precal_movie_avg_score
(
movie_id integer primary key ,
movie_title varchar(500),
avg_score decimal(1000,6),
num_comment bigint,
constraint avg_score_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
        \end{itemize}
        对于“经常合作的演员有哪些”、“经常合作的导演有哪些”和“经常合作的导演和演员有哪些”这三种问题，按照初代物理模型，在每次执行这类查询的时候都必须对所有的演员和导演两两配对计算其一共合作了多少电影。但是导演和演员数量非常多，一共有二十万个，如果要对这二十万人两两配对计算，需要计算四百万次，这是不现实的。对此我们需要预先计算好这些数据，方便以后的查询。但即使是预先计算，四百万次也是个不小的数值，故我们挑选了参演电影书大于等于100的演员和执导电影数大于等于50的导演进行计算，以此简化计算量。计算结果存储在 precal\_collaboration\_actor, precal\_collaboration\_director, precal\_collaboration\_director\_actor 三张表中，表结构如下：
        \begin{itemize}
            \item 演员合作关系表
                \begin{lstlisting}
create table precal_collaboration_actor
(
actor1 varchar(500),
actor2 varchar(500),
collaboration_time integer,
primary key (actor1, actor2),
constraint precal_collaboration_actor_fk1 foreign key (actor1) references prejoin_movie_actor(actor),
constraint precal_collaboration_actor_fk2 foreign key (actor2) references prejoin_movie_actor(actor)
);
                \end{lstlisting}
            \item 导演合作关系表
                \begin{lstlisting}
create table precal_collaboration_director
(
director_name1 varchar(500),
director_name2 varchar(500),
collaboration_time integer,
primary key (director_name1, director_name2),
constraint precal_collaboration_director_fk1 foreign key (director_name1) references prejoin_movie_director(director_name),
constraint precal_collaboration_director_fk2 foreign key (director_name2) references prejoin_movie_director(director_name)
);
                \end{lstlisting}
            \item 导演演员合作关系表
                \begin{lstlisting}
create table precal_collaboration_director_actor
(
director_name varchar(500),
actor varchar(500),
collaboration_time integer,
primary key (director_name, actor),
constraint precal_collaboration_director_actor_fk1 foreign key (director_name) references prejoin_movie_director(director_name),
constraint precal_collaboration_director_actor_fk2 foreign key (actor) references prejoin_movie_actor(actor)
);
                \end{lstlisting}
        \end{itemize}
        \item \textbf{预连接}\\
        用户有大量的查询是针对时间的。在初代物理模型中，观察 movie\_info 和 date 两张表我们可以发现，对于年份和星期的查询可以直接在 movie\_info 表中完成，但是如果涉及到月份、日期、季度和上下半年，就得把 movie\_info 表与 date 表 join 起来，这是非常耗时的。故我们以部分的数据冗余为代价，将这两张表预先连接起来形成 prejoin\_movie\_date 表，表结构如下所示：
        \begin{itemize}
            \item 上映日期预连接表
                \begin{lstlisting}
create table prejoin_movie_date
(
movie_id integer primary key,
movie_title varchar(500),
year integer,
weekday integer,
date integer,
month integer,
year_quarter integer,
year_half integer,
constraint prejoin_movie_date_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
        \end{itemize}
        用户查询指定电影的版本、类型、导演和演员时，往往是指定一个电影的名字，然而在 movie\_actor, movie\_director, movie\_type, movie\_version 和 movie\_review 这五个表中，我们只存了 movie\_id 而并未存 movie\_title，故要想建立 movie\_title 和 movie\_id 的映射关系，我们在每一次查询时都必须将这五张表与 movie\_info 表连接，这是非常耗时的。故我们决定预先完成这些连接过程，形成了 prejoin\_movie\_actor, prejoin\_movie\_director, prejoin\_movie\_type, prejoin\_movie\_version, prejoin\_movie\_review 五张表，表结构如下所示：
        \begin{itemize}
            \item 演员预连接表
                \begin{lstlisting}
create table prejoin_movie_actor
(
movie_id integer,
movie_title varchar(500),
actor varchar(500),
is_lead boolean,
primary key (movie_id, actor),
constraint prejoin_movie_actor_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
            \item 导演预连接表
                \begin{lstlisting}
create table prejoin_movie_director
(
movie_id integer,
movie_title varchar(500),
director_name varchar(500),
primary key (movie_id, director_name),
constraint prejoin_movie_director_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
            \item 电影类型预连接表
                \begin{lstlisting}
create table prejoin_movie_type
(
movie_id integer,
movie_title varchar(500),
type varchar(500),
primary key (movie_id, type),
constraint prejoin_movie_type_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
            \item 电影版本预连接表
                \begin{lstlisting}
create table prejoin_movie_version
(
movie_id integer,
movie_title varchar(500),
version varchar(500),
primary key (movie_id, version),
constraint prejoin_movie_version_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
            \item 影评预连接表
                \begin{lstlisting}
create table prejoin_movie_review
(
productID integer,
movie_title varchar(500),
userID varchar(500),
profileName varchar(500),
num_reader integer,
num_helpfulness integer,
score decimal(2,1),
time date,
summary varchar(10000),
text text,
primary key (productID, userID, score, time, summary),
constraint prejoin_movie_review_fk foreign key (movie_id) references movie_info_fact(movie_id)
);
                \end{lstlisting}
        \end{itemize}
        \item \textbf{建立索引}\\
        通常情况下，在建表时数据库会给主码创建索引，如果想给其他字段建立索引的话需要手动添加。而本项目中我们使用 MySQL 5.7，其有一个特性是在建表时给所有字段全部建立索引，方便了之后的查询操作。例如，我们执行 show index from movie\_review 可以查看 movie\_review 表中的所有索引：
        \begin{figure}[H]
    		\centering
    		\includegraphics[width=0.7\linewidth]{img/index.png}
    		\caption{movie\_review表索引}
    		\label{fig:MySQL_DB2}
    	\end{figure}
    \end{enumerate}
    改进版数据库结构如下图所示：
    \begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/MySQL_DB2.png}
		\caption{改进版表结构}
		\label{fig:MySQL_DB3}
	\end{figure}
	\subsection{实验数据}
	\subsubsection{按时间查询}
	    \begin{enumerate}
	        \item 某某年上映了多少电影？
    	        \begin{itemize}
    	            \item 样例：2008 年上映了多少电影？
    	            \item 结果：11624
    	            \item 耗时：
    	                \begin{itemize}
    	                    \item 执行时间采样：39，31，32，32，34，35，40，35，35，39
    	                    \item 平均执行时间：35.2
    	                \end{itemize}
    	            \item 无需优化
    	        \end{itemize}
    	    \item 某某年某某月上映了多少电影？
    	        \begin{itemize}
    	            \item 样例：2008 年 1 月上映多少电影？
    	            \item 结果：2166
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 131，59，55，64，113，50，107，48，53，100 & 78.0\\
    	                    优化后 &
    	                    40，39，37，38，38，32，37，38，38，31 & 36.8\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：52.8\%
    	        \end{itemize}
    	    \item 某某年某某季度上映了多少电影？
    	        \begin{itemize}
    	            \item 样例：2008 年第一季度上映了多少电影？
    	            \item 结果：3703
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 105，55，65，52，53，63，53，56，66，110 & 67.8\\
    	                    优化后 & 35，33，38，32，33，37，33，35，32，30 & 33.8\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接、预存衍生数据
    	            \item 优化效果：50.1\%
    	        \end{itemize}
    	    \item 周某上映多少电影？
    	        \begin{itemize}
    	            \item 样例：周二上映多少电影？
    	            \item 结果：124840
    	            \item 耗时：
    	                \begin{itemize}
    	                    \item 执行时间采样：41，33，36，42，35，33，56，39，33，40
    	                    \item 平均执行时间：38.8
    	                \end{itemize}
    	            \item 无需优化
    	        \end{itemize}
	    \end{enumerate}
	\subsubsection{按电影名称进行查询}
	    \begin{enumerate}
	        \item 某某电影共有哪些版本？
    	        \begin{itemize}
    	            \item 样例：电影”Beat Street"共有哪些版本？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Prime Video (streaming online video)",
    "Prime Video",
    "Blu-ray",
    "DVD"
],
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 65，61，153，53，135，46，56，63，167，57 & 85.6\\
    	                    优化后 & 36，35，34，32，43，44，34，32，31，29 & 35\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：59.1\%
    	        \end{itemize}
    	    \item 某某电影是什么类型的？
    	        \begin{itemize}
    	            \item 样例：电影“Beat Street”是什么类型的？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Drama",
    "Music Videos and Concerts",
    "All MGM Titles",
    "Musicals"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 135，105，63，51，55，54，58，52，105，52 & 73\\
    	                    优化后 & 39，29，32，29，34，31，35，32，32，35 & 32.8\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：55.1\%
    	        \end{itemize}
    	    \item 某某电影在什么时候上映？
    	        \begin{itemize}
    	            \item 样例：电影"Beat Street"在什么时候上映？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "1984-1-1",
    "2003-4-15"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 128，162，158，95，76，184，69，67，73，94 & 110.6\\
    	                    优化后 & 37，25，33，27，36，27，30，36，28，38 & 31.7\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：71.3\%
    	        \end{itemize}
    	    \item 某某电影有多少同名电影？
    	        \begin{itemize}
    	            \item 样例：电影“Beat Street”有多少同名电影？
    	            \item 结果：2
    	            \item 耗时：
    	                \begin{itemize}
    	                    \item 执行时间采样：43，39，44，43，161，36，38，52，44，67
    	                    \item 平均执行时间：56.7
    	                \end{itemize}
    	            \item 无需优化
    	        \end{itemize}
	        \item 某某电影有哪些演员？
    	        \begin{itemize}
    	            \item 样例：电影“Beat Street”有哪些演员参演？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Jon Chardiet",
    "Saundra Santiago",
    "Guy Davis",
    "Leon W. Grant",
    "Rae Dawn Chong"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 96，66，60，57，60，67，99，62，66，65 & 69.8\\
    	                    优化后 & 43，42，35，41，51，53，87，36，34，38 & 46.0\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：34.1\%
    	        \end{itemize}
	        \item 某某电影导演是谁？
    	        \begin{itemize}
    	            \item 样例：电影”Beat Street“导演是谁？
    	            \item 结果：”Stan Lathan“
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 62，63，68，138，64，167，59，92，161，73 & 94.7\\
    	                    优化后 & 38，34，79，34，31，41，40，34，33，43 & 40.7\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：57.0\%
    	        \end{itemize}
	        \item 某某电影有哪些评论？
    	        \begin{itemize}
    	            \item 样例：电影”Beat Street“有哪些评论？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Kathy Sandoval \"kat3041\" -- 1970/1/16 -- 5.0 -- AWESOME!",
    "Lisa Kerehi -- 1970/1/15 -- 5.0 -- EXCELLENT SERVICE!",
    "Wade S. Pennell -- 1970/1/15 -- 5.0 -- Back when it all started!",
    "MIKE \"MIKE\" -- 1970/1/14 -- 5.0 -- disregard post below, STILL  A CLASSIC, GROUND BREAKER!!",
    "NICKY BRANS -- 1970/1/14 -- 5.0 -- DO NOT HATE",
    "M. Burke -- 1970/1/15 -- 4.0 -- The Foundation",
    "Maria T. Alvarado -- 1970/1/14 -- 5.0 -- 80's movies"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{itemize}
    	                    \item 执行时间采样：328，315，309，319，270，313，345，350，290，239
    	                    \item 平均执行时间：307.8
    	                \end{itemize}
    	            \item 无需优化
    	        \end{itemize}
	        \item 某某电影平均评分是多少？
    	        \begin{itemize}
    	            \item 样例：电影"Beat Street"平均评分多少？
    	            \item 结果：4.391892
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 58，98，58，57，57，61，65，125，58，99 & 73.6\\
    	                    优化后 & 29，30，30，30，30，33，31，29，31，30 & 30.3\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预存衍生数据
    	            \item 优化效果：58.8\%
    	        \end{itemize}
	    \end{enumerate}
	\subsubsection{按导演进行查询}
	    \begin{enumerate}
	        \item 某某导演执导了哪些电影？
    	        \begin{itemize}
    	            \item 样例：Yossi Wein 执导了哪些电影？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Operation Delta Force 5: Random Fire",
    "Fugitive Rage / Merchant Of Death",
    "Death Train",
    "Octopus 2:River of Fear VHS",
    "U.S. Seals",
    "U.S. Seals - Dead Or Alive VHS",
    "Us Seals",
    "Disaster",
    "Merchant of Death",
    "Octopus 2: River of Fear",
    "Death Train VHS",
    "Cult of Fury",
    "Operation Delta Force V:Random Fire VHS",
    "Never Say Die VHS"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 116，50，54，72，56，70，59，60，58，63 & 65.8\\
    	                    优化后 & 39，36，35，34，33，35，34，33，32，33 & 34.4\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：47.7\%
    	        \end{itemize}
	    \end{enumerate}
	\subsubsection{按演员进行查询}
	    \begin{enumerate}
	        \item 某某演员在哪些电影中担任主演？
    	        \begin{itemize}
    	            \item 样例：Harry Shannon 在那些电影中担任主演？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Yellow Rose of Texas VHS",
    "Kansas Pacific",
    "Song Of Texas VHS",
    "Kansas Pacific VHS",
    "The Yellow Rose of Texas",
    "Song of Texas VHS",
    "I Love Lucy: Season 1, Vol.3",
    "The Yellow Rose of Texas VHS"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 201，59，63，58，111，212，64，59，57，103 & 98.7\\
    	                    优化后 & 37，38，39，35，37，37，34，34，32，34 & 35.7\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：63.8\%
    	        \end{itemize}
	        \item 某些演员共同参演过哪些电影？
    	        \begin{itemize}
    	            \item 样例：Jena Malone, Julia Roberts 共同参演过哪些电影？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Stepmom",
    "Stepmom [VHS]",
    "Quedate a Mi Lado VHS",
    "Stepmom VHS"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 150，121，116，140，170，138，175，145，153，165 & 148.2\\
    	                    优化后 & 66，60，61，62，62，63，59，61，60，59 & 61.3\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：58.6\%
    	        \end{itemize}
	    \end{enumerate}
    \subsubsection{对导演和演员关系进行查询}
		\begin{enumerate}
    		\item 经常合作的演员有哪些？
        		\begin{itemize}
        			\item 样例：经常合作的演员有哪些？
        			\item 结果：使用100作为门槛。
        			    \begin{lstlisting}
"data": [
    "Scott McNeil & Doc Harris for 150time(s)",
    "Scott McNeil & Christopher Sabat for 150time(s)",
    "Sean Schemmel & Doc Harris for 153time(s)",
    "William Hartnell & Patrick Troughton for 109time(s)",
    "Jon Pertwee & Patrick Troughton for 110time(s)",
    "Christopher Sabat & Terry Klassen for 150time(s)",
    "Lou Costello & Bud Abbott for 121time(s)",
    "Jon Pertwee & William Hartnell for 108time(s)",
    "Leonard Nimoy & DeForest Kelley for 152time(s)",
    ...
]
        			    \end{lstlisting}
        			\item 耗时：
        			    \begin{itemize}
        			        \item 执行时间采样：40，34，37，37，36，30，28，30，32，30
        			        \item 平均执行时间：33.4
        			    \end{itemize}
        		    \item 必须用预存衍生数据方法进行优化，不优化便无法执行
        		\end{itemize}
            \item 经常合作的导演和演员有哪些？
        		\begin{itemize}
        			\item 样例：经常合作的导演和演员有哪些？
        			\item 结果：使用100作为门槛。
        			    \begin{lstlisting}
"data": [
    "Various & Various for 1419time(s)",
    "Robert Becker & Gates McFadden for 128time(s)",
    "Clint Eastwood & Clint Eastwood for 101time(s)",
    "Gabrielle Beaumont & LeVar Burton for 128time(s)",
    "Gates McFadden & LeVar Burton for 128time(s)",
    "LeVar Burton & Gates McFadden for 128time(s)",
    "Cliff Bole & Gates McFadden for 128time(s)",
    ...
]
        			    \end{lstlisting}
        			\item 耗时：
        			    \begin{itemize}
        			        \item 执行时间采样：32，38，25，27，34，27，30，53，26，27
        			        \item 平均执行时间：31.9
        			    \end{itemize}
        		    \item 必须用预存衍生数据方法进行优化，不优化便无法执行
        		\end{itemize}
    		\item 经常合作的导演有哪些？
        		\begin{itemize}
        			\item 样例：经常合作的导演有哪些？
        			\item 结果：使用50作为门槛。
        			    \begin{lstlisting}
"data": [
    "Shinji Takagi & Takeshi Mori for 64time(s)",
    "LeVar Burton & Gabrielle Beaumont for 128time(s)",
    "LeVar Burton & Gates McFadden for 128time(s)",
    "a & N for 104time(s)",
    "Robert Becker & Gates McFadden for 128time(s)",
    "Jim Martin & Ken Diego for 52time(s)",
    "LeVar Burton & Cliff Bole for 128time(s)",
    "Gates McFadden & Gabrielle Beaumont for 128time(s)",
    ...
]
			            \end{lstlisting}
        			\item 耗时：
        			    \begin{itemize}
        			        \item 执行时间采样：41，29，32，31，30，27，27，32，28，34
        			        \item 平均执行时间：31.1
        			    \end{itemize}
        		    \item 必须用预存衍生数据方法进行优化，不优化便无法执行
        		\end{itemize}
	    \end{enumerate}
	\subsubsection{按电影类别进行查询}
	    \begin{enumerate}
	        \item 某某类型的电影有多少？
    	        \begin{itemize}
    	            \item 样例：类型为 Action 和 Suspense 的电影有多少？
    	            \item 结果：821
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 132，171，210，77，164，187，81，77，108，94 & 130.1\\
    	                    优化后 & 66，67，80，86，65，67，70，74，63，60 & 69.8\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：46.6\%
    	        \end{itemize}
	    \end{enumerate}
	\subsubsection{按用户评价进行查询}
	    \begin{enumerate}
	        \item 评分为某某的电影有哪些？
    	        \begin{itemize}
    	            \item 样例：观众平均评分为 5 的电影有哪些？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "60 Minutes - Dumped on Skid Row May 20, 2007",
    "Barrow, Alaska: Our Tales to Tell",
    "Black Adder Series 3, Part 1 VHS",
    "Bob Hope, Bing Crosby, Dean Martin, Jerry Lewis",
    "Cafe Au Lait - with lotsa sugar, baby!",
    "Cancer, Nutrition & Healing",
    "Coleccion de Oro: Jorge Negrete, Vol. 1"
    ......
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 1587，1008，1224，930，1187，1563，987，976，1118，1125 & 1170.5\\
    	                    优化后 & 785，988，762，819，753，819，580，1105，994，678 & 828.3\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：29.2\%
    	        \end{itemize}
	        \item 某某用户喜欢的电影有哪些？
    	        \begin{itemize}
    	            \item 样例：用户ID为AWKP2OZY4WB8M的用户喜欢（评分大于4）的电影有哪些？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
    "Vampire Princess Miyu: The Last Shinma - Volume 6",
    "Once Upon a Time in Mexico",
    "Spirited Away VHS",
    "El Mariachi (English Subtitled)",
    "Spirited Away",
    "Vampire Hunter D - Bloodlust VHS",
    "Vampire Hunter D VHS",
    "Once Upon A Time In Mexico",
    "Pistolero VHS",
    ......
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 63，64，53，62，53，57，53，57，57，54 & 57.3\\
    	                    优化后 & 30，33，33，30，32，31，31，35，29，39 & 32.3\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：预连接
    	            \item 优化效果：43.6\%
    	        \end{itemize}
	    \end{enumerate}
	\subsection{实验结论}
	MySQL作为关系型数据库的佼佼者，对于传统的查询表现出极高的效率，同时也具有不俗的插入、删除和修改效率。此外，其性能十分稳定，在执行大批量数据导入操作时从未出现过异常中断，且对于相同的查询语句执行时间基本相同，不会出现其他类型数据库那样的较大波动。
    通过预连接、预存衍生数据和插入索引的优化方式，MySQL的查询效率更加高效，可以看到大部分的查询所耗的时间都缩短了一半以上。我们并未一味地追求效率而完全放弃对减少数据冗余的追求，而是适可而止地对部分表进行预连接，这些预连接操作在数据量为20亿的时候仍可以完成。
    但MySQL也有不足之处，对于对象之间的关系的查询它就显得力不从心。我们可以看到如果要查询哪些演员经常合作，就必须让演员们两两配对，依次计算它们的合作次数，这样做的效率是十分低下的。如果为了避免在执行查询时进行繁琐的计算而预先存储查询结果，这么做会小号大量的存储空间，且不利于数据更新。
	
	\section{分布式文件系统}
	\subsection{概述}
	为了体现分布式的特点，我们小组在阿里云上租了5台云主机，在这5台云主机上搭建了Hadoop集群，并以此为基础搭建了Hbase集群。然后我们小组将电影信息以及电影评论的数据导入Hbase集群中，并根据给定的查询类型在存储方案上作出了一些优化。
	我们所租的五台云主机配置相同，详细信息如下：

	\begin{longtable}{l|p{5cm}|l}
		\hline
		CPU & 内存 & 磁盘\\
		\hline
		\hline
		一核 &2G & 40G SSD高性能云盘\\
		\hline
		\caption{执行时间比较}
	\end{longtable}
	HBase集群一览
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/HBase_cluster.jpg}
		\caption{HBase集群一览}
		\label{fig:HBase_cluster}
	\end{figure}
	\subsection{存储模型及其优化方案}
	\subsubsection{初步想法}
	由于Hbase为列数据库，并不能像关系型数据库那样进行join操作，所以无需遵循第一范式，我们建立了两张大表来存储电影信息和电影评论
	\begin{itemize}
		\item dw\_movieInfo
			\begin{itemize}
				\item title(行键)
				\item movie（列族)，分别有如下列：
				\begin{itemize}
					\item id，同一部电影的所有id，为多值属性，以逗号拼接而成
					\item director，一部电影的所有导演，为多值属性，以逗号拼接而成，可能为空
					\item date，电影的上映日期，可能为空
					\item type，电影的类型，多值属性，以逗号拼接而成，可能为空
					\item version，电影的版本，多值属性，以逗号拼接而成，可能为空
					\item actor，电影的演员，多值属性，以逗号拼接而成，可能为空
				\end{itemize}
			\end{itemize}
		\item dw\_movieComment
			\begin{itemize}
				\item index（行键），由于电影评论中无具有唯一性的属性，所以行键设置为递增的整型数字
				\item comment（列族），分别有如下列：
				\begin{itemize}
					\item product\_id，电影ID
					\item user\_id，用户ID
					\item profile\_name，用户名
					\item helpfulness，帮助性
					\item score，评分
					\item review\_time，评论时间
					\item summary，总结
					\item review\_text，评论文字
				\end{itemize}
			\end{itemize}
	\end{itemize}
	\subsubsection{深入改进}
	在本机测试上述模型后发现比较慢，主要因为在Hbase中带有列过滤器的查询比较慢，所以考虑将要作为查询依据的属性和一些其他属性单独存到新的表中，然后以作为查询依据的属性为行键。这样我们又新建了以下几个表：
	\begin{itemize}
		\item dw\_movieInfo\_time
			\begin{itemize}
				\item 发行时间+递增整型数字（行键）
				\item timeMap（列族），有如下列：
				\begin{itemize}
					\item title，电影名
				\end{itemize}
			\end{itemize}
		\item dw\_movieInfo\_director
			\begin{itemize}
				\item 导演名+递增整型数字（行键）
				\item directorMap（列族），有如下列：
				\begin{itemize}
					\item title，电影名
				\end{itemize}
			\end{itemize}
		\item dw\_movieInfo\_actor
		\begin{itemize}
			\item 演员+递增整型数字（行键）
			\item actorMap（列族），有如下列：
			\begin{itemize}
				\item title，电影名
			\end{itemize}
		\end{itemize}
		\item dw\_movieInfo\_type
		\begin{itemize}
			\item 电影类型+递增整型数字（行键）
			\item typeMap（列族），分别有如下列：
			\begin{itemize}
				\item title，电影名
			\end{itemize}
		\end{itemize}
		\item dw\_movieInfo\_id
		\begin{itemize}
			\item 电影id（行键）
			\item idMap（列族），分别有如下列：
			\begin{itemize}
				\item title，电影名
			\end{itemize}
		\end{itemize}
	\end{itemize}
	优化后的表一览
        \begin{figure}[H]
    		\centering
    		\includegraphics[width=0.7\linewidth]{img/Hbase_tables.jpg}
    		\caption{Hbase 表一览}
    		\label{fig:Hbase_tables}
    	\end{figure}
	\subsection{实验数据}
	\subsubsection{按时间查询}
	    \begin{enumerate}
	        \item 某某年上映了多少电影？
    	        \begin{itemize}
    	            \item 样例：2007 年上映了多少电影？
    	            \item 结果：12117
    	            \item 耗时：
						\begin{longtable}{l|p{5cm}|l}
							\hline
							是否优化 & 执行时间采样 & 平均执行时间\\
							\hline
							\hline
							优化前 &4435, 774, 818, 977, 755, 639, 732, 580, 741, 582 & 1103.3\\
							优化后 &480, 157, 126, 310, 411, 297, 223, 187, 156, 271 & 261.8\\
							\hline
							\caption{执行时间比较}
						\end{longtable}
					\item 优化方法：将日期作为行键新建表
					\item 优化效果：76.3%
    	        \end{itemize}
    	    \item 某某年某某月上映了多少电影？
    	        \begin{itemize}
    	            \item 样例：2007 年 1 月上映多少电影？
    	            \item 结果：2066
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 &584, 459, 476, 595, 555, 597, 627, 447, 599, 488 & 542.7\\
    	                    优化后 &67， 63， 102， 102，102，64，159，54，71，65 & 84.9\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：将日期作为行键新建表
    	            \item 优化效果：84.3\%
    	        \end{itemize}
    	    \item 某某年某某季度上映了多少电影？
    	        \begin{itemize}
    	            \item 样例：2007 年第一季度上映了多少电影？
    	            \item 结果：
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 627，697，606，599，627，632，589，620，728，610 & 633.5\\
    	                    优化后 & 117，116，128，129，92，153，113，107，115，134 & 120.4\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：将时间作为行键新建表
    	            \item 优化效果：82.2\%
    	        \end{itemize}
    	    \item 周某上映多少电影？
    	        \begin{itemize}
    	            \item 样例：周二上映多少电影？
    	            \item 结果：124840
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 4102，1529，1503，1300，1315，1471，1483，1343，1338，1342 & 1672.6\\
    	                    优化后 & 2000，750，637，632，599，499，500，572，509，528 & 722.6\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化效果：56.8\%
    	        \end{itemize}
	    \end{enumerate}
	\subsubsection{按电影名称进行查询}
	    \begin{enumerate}
	        \item 某某电影是什么类型的？
    	        \begin{itemize}
    	            \item 样例：电影"Flintstones, The:S1 (DVD)"是什么类型的？
    	            \item 结果：
    	                \begin{lstlisting}
"data": [
	"Animation",
]
    	                \end{lstlisting}
					\item 耗时：
					\begin{itemize}
						\item 执行时间采样：2498，454，397，491，377，396，403，406，433，410
						\item 平均执行时间：1067.5
					\end{itemize}
				\item 无优化
				\end{itemize}
		\end{enumerate}
	\subsubsection{按导演进行查询}
	    \begin{enumerate}
	        \item 某某导演执导了哪些电影？
    	        \begin{itemize}
    	            \item 样例：Ashwin Batish 执导了哪些电影？
    	            \item 结果：
						\begin{lstlisting}
"data": [
"Detective Inspector Irene Huss: Series 1, The Glass Devil (English Subtitled)",
"Detective Inspector Irene Huss: Series 1, The Night Round (English Subtitled)",
"Detective Inspector Irene Huss: Series 1, The Torso (English     Subtitled)",
"Detective Inspector Irene Huss: Series 1,The Fire Dance (English Subtitled)",
"Wallander: Episodes 1-3"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 690，467，482，513，453，396，455，404，482，378 & 472\\
    	                    优化后 & 73，14，14，16，17，14，20，15，27，17 & 22.7\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：将导演作为行键建立新表
    	            \item 优化效果：95.2\%
    	        \end{itemize}
	    \end{enumerate}
	\subsubsection{按演员进行查询}
	    \begin{enumerate}
	        \item 某某演员在哪些电影中出演？
    	        \begin{itemize}
    	            \item 样例：Angela Kovacs 出演过哪些电影？
    	            \item 结果：
						\begin{lstlisting}
"data": [
	"Detective Inspector Irene Huss: Series 1, The Glass Devil (English Subtitled)",
	"Detective Inspector Irene Huss: Series 1, The Night Round (English Subtitled)",
	"Detective Inspector Irene Huss: Series 1, The Torso (English     Subtitled)",
	"Detective Inspector Irene Huss: Series 1,The Fire Dance (English Subtitled)",
	"Wallander: Episodes 1-3"
]
    	                \end{lstlisting}
    	            \item 耗时：
    	                \begin{longtable}{l|p{5cm}|l}
    	                    \hline
    	                    是否优化 & 执行时间采样 & 平均执行时间\\
    	                    \hline
    	                    \hline
    	                    优化前 & 391，391，418，477，380，417，365，373，355，386 & 395.3\\
    	                    优化后 & 32，25，17，17，14，10，20，11，13，11 & 17.3\\
    	                    \hline
    	                    \caption{执行时间比较}
    	                \end{longtable}
    	            \item 优化方法：将演员作为行键建立新表
    	            \item 优化效果：95.6\%
    	        \end{itemize}
	    \end{enumerate}
	\subsection{实验结论}
	
	\section{图数据库}
	\subsection{概述}
	根据课程中朱老师的建议，我们使用了最有名的图数据库Neo4j来作为本项目的图数据库部分存储方案。与前两者采用的云端方案不同，我们在图数据库部分直接使用的是Neo4j的桌面版本，以便能够更好的使用Neo4j Browser 来进行数据模型的可视化。总而言之，在图数据库部分选择的软件版本与配置信息如下所示：
	\begin{longtable}{l|l}
		\hline
		条目 & 说明\\
		\hline
		\hline
		Neo4j版本 & 3.5.12 Enterprise\\
		Neo4j Zulu 允许内存 & 6G \\
		\hline
		笔记本操作系统 & Windows 10 专业版 64 位 \\
		笔记本处理器 & Intel(R) Core(TM) i7-7700HQ CPU @ 2.8GHZ \\
		笔记本内存 & 16GB\\
		\hline
		\caption{配置信息}
	\end{longtable}
	在图数据库的存储部分，我们根据项目文档中所提出的常见搜索的要求，将电影以及评论信息分别抽取出相应的节点并且使用边将它们连接起来，主要的节点标签有以下几种：\begin{itemize}
	  	\item MOVIE
	  	\item MOVIE\_ID
	  	\item COMMENT
	  	\item USER
	  	\item ACTOR
	  	\item TYPE
	  	\item DIRECTOR
	  	\item VERSION
	  	\item YEAR
	  	\item QUARTER
	  	\item MONTH
	  	\item DAYOFWEEK
	  	\item DAYOFMONTH
	\end{itemize}
	它们之间具体是怎样连接以及经历了怎样的演化过程，我们将在下一节详细描述。
	\subsection{存储模型及其优化方案}
	在本部分仅仅给出大致时间数据，在下一节中我们给出具体的实验数据。
	\subsubsection{初步模型} \label{neo:1}
	在简单阅读了Neo4j的有关介绍之后，我们快速上手做出了初次原型，使用Neo4j Browser生成的数据库模式图如下所示：
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{img/graph1}
	\caption{第一次结构}
	\label{fig:graph1}
\end{figure}
	其中每个标签的节点的具体信息如下表所示\begin{longtable}{l|p{8cm}}
		\hline
		标签 & 属性与索引（加粗字段） \\
		\hline
		\hline
		ACTOR & \textbf{name} \\
		COMMENT & summary, score, review\_time, review\_text, helpfullness, profile\_name, user\_id \\
		DIRECTOR & \textbf{name}\\
		MOVIE & \textbf{name}, score, commentNumber, releaseDate, totalScore \\
		MOVIE\_ID & \textbf{id} \\
		TYPE & \textbf{name}\\
		VERSION & \textbf{name}\\
		\hline
		\caption{节点信息-1}
	\end{longtable}
	我们可以看到，这种建模方式和关系型的建模方式是有类似的地方的。我们将「多值属性」抽离成单独的节点，然后用边（类似于外键）把它们连接起来。事实上这种方式虽然非常简单，但是已经足够可以解决绝大部分的Query了。在向Neo4j数据库插入值的过程中，我们发现随着插入数量的上升，插入的速度会逐渐变慢 \footnote{我们认为因此这个问题的主要原因在于，我们在插入的过程中使用了 MERGE 以及 MATCH 语句，它们事实上涉及到查询，而正是查询消耗了越来越多的时间}，为了解决这个问题，我们在插入的过程中建立了以下索引，使得插入速度有了明显的上升，如下图所示，在插入到3万条左右的时候，每插入500条已经需要两份半，在对电影ID加入索引之后时间下降到一分钟，在各个name属性上加入索引之后，插入时间下降到30s左右，并随着插入数量的上升而慢慢上升。
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/indexInInsersion}
		\caption{插入过程log}
		\label{fig:index}
	\end{figure}
	这种方法存在问题的地方有两个\begin{enumerate}
		\item 时间是使用时间戳来存储的，查询需要自行换算成范围，而对「周二上映的电影有多少」这样的问题实际上无从回答。
		\item 用户没有被显式的抽取，这将给对用户的分析带来不便。
	\end{enumerate}
事实上，后面的各种改动都是针对这样的问题来进行的。
	
	\subsubsection{提取时间} \label{neo:2}
	由于第一种方案中存在的针对时间的查询难以进行的情况，我们提出了新的方案，也即是将时间作为新的节点抽取出来，而不是作为电影节点的属性。同时我们必须考虑到如下问题：\textbf{要怎样构造节点才能使得针对类似于「1998年第一季度所有周二一共有几部电影」这样复合问题的查询变得简明而易于书写？}同时性能上也要有保障。在一番考虑之后，我们采取了如下的节点结构，即使用YEAR、QUARTER、MONTH、DAYOFWEEK以及DAYOFMONTH来构造层次化的结构，使得针对任意组合的查询语句只需要进行拼接就可以完成。具体的结构示意图如下所示：
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/graph2}
		\caption{第二次结构}
		\label{fig:graph2}
	\end{figure}
	
	其中每个标签的节点的具体信息如下表所示\begin{longtable}{l|p{8cm}}
		\hline
		标签 & 属性与索引（加粗字段）  \\
		\hline
		\hline
		YEAR & num\\
		QUARTER & num \\
		MONTH & num\\
		DAY\_OF\_MONTH & num\\
		DAY\_OF\_WEEK & num \\
		\hline
		ACTOR & \textbf{name} \\
		COMMENT & summary, score, review\_time, review\_text, helpfullness, profile\_name, user\_id \\
		DIRECTOR & \textbf{name}\\
		MOVIE & \textbf{name}, \textbf{score}, commentNumber, releaseDate, totalScore \\
		MOVIE\_ID & \textbf{id} \\
		TYPE & \textbf{name}\\
		VERSION & \textbf{name}\\
		\hline
		\caption{节点信息-2}
		\end{longtable}
	在采取了这样的方式之后，由于每个时间节点之间都是OF关系，我们的查询语句的拼接变得非常简单，使用如下所示的结构可以轻松的完成针对任意组合条件进行的查询。\begin{lstlisting}[language=java]
if(timeFrom.getYear() != 0){
  matchingClause += "(y:YEAR{num: " + timeFrom.getYear() +" })-[:OF]->";
}
if(timeFrom.getQuarter() != 0){
  matchingClause += "(q:QUARTER{num: "+ timeFrom.getQuarter() +" })-[:OF]->";
}
if(timeFrom.getMonth() != 0){
  matchingClause +="(m:MONTH{num: "+ timeFrom.getMonth() +" })-[:OF]->";
}
if(timeFrom.getDay_of_week() != 0){
  matchingClause +="(dow:DAY_OF_WEEK{num: "+ timeFrom.getDay_of_week() +" })-[:OF]->";
}
if(timeFrom.getDay_of_month() != 0){
  matchingClause +="(dom:DAY_OF_MONTH{num: "+ timeFrom.getDay_of_month() +"})-[:OF]->";
}
	\end{lstlisting}
	
	\subsubsection{提取用户}\label{neo:3}
	为了分析与用户有关的数据，我们必须把原本的评论节点中的有关用户的信息进行抽取，使它们成为单独的节点，从而便于后续的处理。因此，我们对原来的结构进行了拓展，使得结构整体如下图所示：
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/graph3}
		\caption{第三次结构}
		\label{fig:graph3}
	\end{figure}
	
	其中每个标签的节点的具体信息如下表所示\begin{longtable}{l|p{8cm}}
		\hline
		标签 & 属性与索引（加粗字段）  \\
		\hline
		\hline
		USER & \textbf{profile\_name}, \textbf{user\_id }\\
		\hline
		YEAR & num\\
		QUARTER & num \\
		MONTH & num\\
		DAY\_OF\_MONTH & num\\
		DAY\_OF\_WEEK & num \\
		ACTOR & \textbf{name} \\
		COMMENT & summary, score, review\_time, review\_text, helpfullness, profile\_name, user\_id \\
		DIRECTOR & \textbf{name}\\
		MOVIE & \textbf{name}, \textbf{score}, commentNumber, releaseDate, totalScore \\
		MOVIE\_ID & \textbf{id} \\
		TYPE & \textbf{name}\\
		VERSION & \textbf{name}\\
		\hline
		\caption{节点信息-3}
	\end{longtable}
	在进行了这样的修改之后，类似于「某某用户喜欢的电影有哪些？」这样的查询已经可以相对快速的进行了，但是我们希望可以再进一步，完成这样的一组查询\textbf{哪些用户是相似的？}这样的查询所具有的意义是非凡的。我们首先定义什么是相似的：如果两个用户在对同一部电影的评分上相差无几，我们就认为这两位用户对该电影的看法是一致的，如果两个用户在相当数目的电影上的看法都是一致的，我们就可以认为两个用户对于电影的爱好是一致的。如果两个用户被判断为一致的，那么我们就可以将一个用户喜欢而另一个用户还没有看过的电影推荐给还没有看过的那位用户，这部电影会有较大的概率被这个用户喜欢。因此我们尝试在现有的结构上进行这样的查询：\begin{lstlisting}
match (u1:USER)-[:SAYS]->(c1:COMMENT)-[:COMMENT_ON]->(m:MOVIE)<-[:COMMENT_ON]-(c2:COMMENT)<-[:SAYS]-(u2:USER) where abs(c1.score-c2.score)<=1 return u1,u2,count(m) order by count(m) desc
	\end{lstlisting}
	但是经过我们的实验发现，这样的查询在我们现有的6G内存上是远远无法完成的，Neo4j会报告内存溢出并停止查询。在这种情况下我们咨询了朱老师，朱老师建议我们限制查询的电影和评论数量，只考虑最火的那些电影，并对它们进行处理。结合朱老师的建议，我们再对图的结构进行了一次改进，从而可以在较大的粒度上实现这个功能。具体的优化方式如下一节所提到的。
	\subsubsection{优化用户聚类} \label{neo:4}
	由于现在用户连接到自己所评论的电影中间需要经过大量的评论节点，我们猜测这有可能会导致对于内存的大量使用，因此我们将用户和电影之间直接连接起来，从而节省内存的使用。为了进一步简化数据库所必须要做出的操作，我们甚至在数据库内部做出了这样的规定：所有评分高于4分的被认为是喜欢，从而直接使用LIKES边进行连接。这使得二者之间的连接关系进一步的简化。但是仅仅做出这样的改变是不够的，我们还需要像朱老师提到的那样限制电影的数量来使得查询在合适的时间范围内进行。在我们现在的设备上，我们只能考虑评论数量在700以上的电影。至此，我们相当于在受限的条件上完成了我们想进行的搜索，而上文中关于相似的定义事实上在这里被窄化到：如果两个用户都喜欢一部电影，那么这两个用户被在这部电影上的看法被认为是类似的。同样，在此时我们的存储整体结构如下图所示：
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{img/graph4}
		\caption{第四次结构}
		\label{fig:graph4}
	\end{figure}
	其中每个标签的节点的具体信息如下表所示\begin{longtable}{l|p{8cm}}
		\hline
		标签 & 属性与索引 （加粗字段） \\
		\hline
		\hline
		USER &\textbf{ profile\_name}, \textbf{user\_id} \\
		YEAR & num\\
		QUARTER & num \\
		MONTH & num\\
		DAY\_OF\_MONTH & num\\
		DAY\_OF\_WEEK & num \\
		ACTOR & \textbf{name} \\
		COMMENT & summary, score, review\_time, review\_text, helpfullness, profile\_name, user\_id \\
		DIRECTOR & name\\
		MOVIE & \textbf{name}, \textbf{score}, \textbf{commentNumber}, releaseDate, totalScore \\
		MOVIE\_ID & \textbf{id} \\
		TYPE & \textbf{name}\\
		VERSION & \textbf{name}\\
		\hline
		\caption{节点信息-4}
	\end{longtable}
	\subsection{实验数据}
	\subsubsection{按时间查询}
	\begin{enumerate}
		\item 某某年上映了多少电影？\begin{itemize}
			\item 样例：2008 年上映了多少电影？
			\item 结果：11593
			\item 平均执行时间：20-30ms。本查询在 \ref{neo:2} 方案中才能实现，在之后没有明显变化。
		\end{itemize}
		\item 某某年某某月上映了多少电影？\begin{itemize}
			\item 样例：2008 年 1 月上映多少电影？
			\item 结果：2162
			\item 平均执行时间：20ms。本查询在 \ref{neo:2} 方案中才能实现，在之后没有明显变化。
		\end{itemize}
		\item 某某年某某季度上映了多少电影？\begin{itemize}
			\item 样例：2008 年第一季度上映了多少电影？
			\item 结果：3699
			\item 平均执行时间：40ms。本查询在 \ref{neo:2} 方案中才能实现，在之后没有明显变化。
		\end{itemize}
		\item 周某上映多少电影？\begin{itemize}
			\item 样例：周二上映多少电影？
			\item 结果：35619
			\item 平均执行时间：32ms。本查询在 \ref{neo:2} 方案中才能实现，在之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{按电影名称进行查询}
	 说明：在我们的项目中，为了降低用户搜索难度，使用的是模糊搜索，这导致对于电影名的搜索非常缓慢而几乎不能完成。下面的数据来自于非模糊搜索的结果。
		\begin{enumerate}
		\item 某某电影共有哪些版本？\begin{itemize}
			\item 样例：电影”Beat Street"共有哪些版本？
			\item 结果：\begin{lstlisting}
"data": [
  "Prime Video (streaming online video)",    
 "Prime Video",
 "Blu-ray",
 "DVD"
],
			\end{lstlisting}
			\item 平均执行时间：50ms。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某电影是什么类型的？\begin{itemize}
			\item 样例：电影“Beat Street”是什么类型的？
			\item 结果：\begin{lstlisting}
"data": [
  "Drama",
  "Music Videos and Concerts",
  "All MGM Titles",
  "Musicals"
]
			\end{lstlisting}
			\item 平均执行时间：1ms\footnote{不知道为何会有这样的速度，我们猜测是缓存}。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某电影在什么时候上映？\begin{itemize}
			\item 样例：电影"Beat Street"在什么时候上映？
			\item 结果：\begin{lstlisting}
"data": [
  "1984-1-1",
  "2003-4-15"
]
			\end{lstlisting}
			\item 平均执行时间：10ms\footnote{波动巨大，有时0ms}。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某电影有多少同名电影？\begin{itemize}
			\item 样例：电影“Beat Street”有多少同名电影？
			\item 结果：4
			\item 平均执行时间：295ms。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某电影有哪些演员？\begin{itemize}
			\item 样例：电影“Beat Street”有哪些演员参演？
			\item 结果：\begin{lstlisting}
"data": [
  "Jon Chardiet",
  "Saundra Santiago",
  "Guy Davis",
  "Leon W. Grant",
  "Rae Dawn Chong"
]
			\end{lstlisting}
			\item 平均执行时间：150ms。 本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某电影导演是谁？\begin{itemize}
			\item 样例：电影”Beat Street“导演是谁？
			\item 结果：Stan Lathan
			\item 平均执行时间：50ms。\footnote{波动巨大，有时0ms}本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某电影有哪些评论？\begin{itemize}
			\item 样例：电影”Beat Street“有哪些评论？
			\item 结果：\begin{lstlisting}
""This ain't New York, this is the Bronx!""
"Yay Breakin!"
"Old School At It's Best"
"A MUST HAVE !!!!!"
"Great Film"
"Love this Movie and Soundtracks"
...
			\end{lstlisting}
			\item 平均执行时间：5ms。\footnote{波动巨大，有时0ms}本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{按导演进行查询}
		\begin{enumerate}
		\item 某某导演执导了哪些电影？\begin{itemize}
			\item 样例：Yossi Wein 执导了哪些电影？
			\item 结果：\begin{lstlisting}
"Operation Delta Force 5: Random Fire",
"Fugitive Rage / Merchant Of Death",
"Death Train",
"Octopus 2:River of Fear VHS",
"U.S. Seals",
"U.S. Seals - Dead Or Alive VHS",
"Us Seals",
"Disaster",
"Merchant of Death",
"Octopus 2: River of Fear",
"Death Train VHS",
"Cult of Fury",
"Operation Delta Force V:Random Fire VHS",
"Never Say Die VHS"
			\end{lstlisting}
			\item 平均执行时间：50ms\footnote{时间波动极大，有时只要几毫秒}。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{按演员进行查询}
		\begin{enumerate}
		\item 某某演员在哪些电影中担任主演？\begin{itemize}
			\item 样例：Harry Shannon 在那些电影中担任主演？
			\item 结果：\begin{lstlisting}
"Yellow Rose of Texas VHS",
"Kansas Pacific",
"Song Of Texas VHS",
"Kansas Pacific VHS",
"The Yellow Rose of Texas",
"Song of Texas VHS",
"I Love Lucy: Season 1, Vol.3",
"The Yellow Rose of Texas VHS"
			\end{lstlisting}
			\item 平均执行时间：60ms。\footnote{时间波动极大，有时只要几毫秒}本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某演员参演多少电影？\begin{itemize}
			\item 样例：Harry Shannon 在那些电影中参演过？
			\item 结果：\begin{lstlisting}
"Yellow Rose of Texas VHS",
"The Yellow Rose of Texas VHS",
"The Yellow Rose of Texas",
"Song of Texas VHS",
"Song Of Texas VHS",
"Song of Texas",
"Kansas Pacific",
"Kansas Pacific VHS",
"Cow Town",
"I Love Lucy: Season 1, Vol.3"
			\end{lstlisting}
			\item 平均执行时间：35ms。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{对导演和演员关系进行查询}
		\begin{enumerate}
		\item 经常合作的演员有哪些？\begin{itemize}
			\item 样例：经常合作的演员有哪些？
			\item 结果：使用32作为门槛。\begin{lstlisting}
"Claudia Black & Ben Browder for 66time(s)",
"Terry Gilliam & Graham Chapman for 62time(s)",
"Tom Baker & Patrick Troughton for 108time(s)",
"Noel MacNeal & Tyler Bunch for 55time(s)",
"Alexandra Isles & Joan Bennett for 38time(s)",
"Trigger & Roy Rogers for 88time(s)",
"Courteney Cox & Jennifer Aniston for 56time(s)",
...
			\end{lstlisting}
			\item 平均执行时间：5500-8000ms本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 经常合作的演员和导演有哪些？\begin{itemize}
			\item 样例：经常合作的导演有哪些？
			\item 结果：使用32作为门槛。\begin{lstlisting}
"Basil Rathbone & Roy William Neill for 79time(s)",
"Megumi Hayashibara & Takeshi Mori for 65time(s)",
"Robert Smigel & Robert Smigel for 37time(s)",
"Richard Ian Cox & Naoya Aoki for 39time(s)",
"Tim Russ & Kenneth Biller for 39time(s)", 
"Peter Linz & Jim Martin for 48time(s)",
"Claudia Black & Ian Watson for 48time(s)",
"Lynne Thigpen & Jim Martin for 41time(s)",
"Kappei Yamaguchi & Tomomi Mochizuki for 54time(s)",
"Justin Cook & Noriyuki Abe for 43time(s)",
"Marc Weiner & Sherie Pollack for 43time(s)",
"n & a for 193time(s)",
"Anthony Simcoe & Geoff Bennett for 48time(s)",
"n & n for 193time(s)",
"Trigger & William Witney for 57time(s)",
"Roy Rogers & William Witney for 69time(s)",
"Charles Chaplin & Charles Chaplin for 54time(s)",
"Jonathan Hardy & Ian Watson for 43time(s)",
"Laura Bailey (II) & Noriyuki Abe for 43time(s)",
"Charles Hawtrey & Gerald Thomas for 62time(s)",
"John Wayne & John Ford for 59time(s)",
...
			\end{lstlisting}
			\item 平均执行时间：1427ms。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 经常合作的导演有哪些？\begin{itemize}
			\item 样例：经常合作的导员和演员有哪些？
			\item 结果：使用32作为门槛。\begin{lstlisting}
"Cliff Bole & Gabrielle Beaumont for 167time(s)",
“Ikur? Sat? & Hirokazu Yamada for 33time(s)",
"Geoff Bennett & Ian Watson for 48time(s)",
"Gary Goldman & Don Bluth for 38time(s)",
"N & A for 36time(s)",
"Gates McFadden & LeVar Burton for 128time(s)",
"Rocky Collins & Matthew Collins (III) for 53time(s)",
"Robert Becker & LeVar Burton for 128time(s)",
"Angela Santomero & John Rowe for 33time(s)",
 "Arthur Rankin Jr. & Jules Bass for 68time(s)",
"LeVar Burton & Cliff Bole for 128time(s)",
...
			\end{lstlisting}
			\item 平均执行时间：897ms。本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{按电影类别进行查询}
		\begin{enumerate}
		\item 某某类型的电影有多少？\begin{itemize}
			\item 样例：类型为 Action的电影有多少？
			\item 结果：23055
			\item 平均执行时间：本查询在方案 \ref{neo:1}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{按用户评价进行查询}
		\begin{enumerate}
		\item 评分为某某的电影有哪些？\begin{itemize}
			\item 样例：观众平均评分为 5 的电影有哪些？
			\item 结果：\begin{lstlisting}
"Andy's Airplanes, Andy Meets the Blue Angels",
"Animal Rescue, Vol. 2: Best Cat Rescues",
"Animals Rock with Lucas Miller! Vol. 1 Monarchs, Metamorphosis and More!",
"Animals and Man Animal Safari, vol.6  VHS",
"Animals of the Amazon Animal Safari, vol.2  VHS",
"Animals of the Rain Forest Art Lessons for Children, Vol. 5  VHS",
"Animaniacs, Vol. 4",
"Animorphs - The Invasion Series, Part 2: Nowhere to Run VHS",
...
			\end{lstlisting}
			\item 平均执行时间：75ms。本查询在方案 \ref{neo:3}中就可以实现，并且之后没有明显变化。
		\end{itemize}
		\item 某某用户喜欢的电影有哪些？\begin{itemize}
			\item 样例：用户ID为AWKP2OZY4WB8M的用户喜欢（评分大于4）的电影有哪些？
			\item 结果：\begin{lstlisting}
"Vampire Princess Miyu: The Last Shinma - Volume 6"
"Vampire Hunter D: Bloodlust"
"Vampire Hunter D"
"Vampire Hunter D VHS"
"Vampire Hunter D - Bloodlust VHS"
"Vampire Hunter D - Bloodlust"
"Spirited Away"
			\end{lstlisting}
			\item 平均执行时间：600ms\footnote{受缓存影响极大}。本查询在方案 \ref{neo:3}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsubsection{综合查询}
		\begin{enumerate}
		\item 相似的用户有哪些？\begin{itemize}
			\item 样例：相似的用户有哪些？
			\item 结果：\begin{lstlisting}
Lawrance M. Bernabo & Jenny J.J.I. "A New Yorker" 51times
Monkdude & Wayne Klein "If at first the idea is not absu... 47times
...
			\end{lstlisting}
			\item 平均执行时间：110531ms。本查询在方案 \ref{neo:4}中就可以实现，并且之后没有明显变化。
		\end{itemize}
	\end{enumerate}
	\subsection{实验结论}
	综合以上的探索，我们可以得到以下的结论，使用图数据库更加有利于对\textbf{关系}进行查询。我们可以看到差距最为明显的就是有关对导演和演员关系进行查询以及有关相似的用户的查询。这两种查询借用朱老师的话来说是\textbf{没有起点}的，使用传统的SQL语言很难书写出高效而又简明的查询语句。而这种情况在我们的图数据库实际上是不存在的。我们可以使用最简单的结构（例如在 \ref{neo:1} 中使用的简单结构）就能相对高效的完成所需要的查询。这得益于图的结构中\textbf{关系被显式存储而非需要计算\footnote{就像在遵从范式的数据库中使用大量的join操作来进行复杂查询那样。}}。更有帮助的是，使用Neo4j所支持的特殊查询语言Cypher我们可以使用一种非常符合直觉的方式来进行查询（事实上我们认为Cypher查询语言的表达能力也许高于SQL），这些都是图数据库所具有的优势，而且我们认为这种优势是独一无二而且持续的，这使得它难以被其他的存储方案所超越。
	
	但是在使用的过程中，图数据库（特指Neo4j）这款图数据库给我们的感觉是它不如类似MySQL这样的数据库那样稳定，那样坚如磐石。我们曾经有一次在使用Neo4j进行大量数据写入的过程中，Windows系统不幸崩溃蓝屏了，是硬盘驱动的问题。在重新启动电脑之后，我们再想打开那个数据库的时候，Neo4j只是不停的加载，丝毫没有要开启的意思，没有办法，我们只能把老的数据库删除，把数据再往新的数据库里面导入一次。除此之外，我们认为Neo4j可能倾向于在类似认为上相比于成熟的关系型数据库使用了更多的内存，但是并没有对此进行细致的定量研究。
	
	总而言之，我们认为图数据库是具有不可代替的重大作用的数据库，它在对于关系的处理上如鱼得水，游刃有余，我们必须注意到它的重要意义。除此之外，我们也必须认识到，Neo4j的定位应当放在数据仓库（OLAP），而不是在线交易（OLTP），那也许会给系统引入不必要的风险。
\end{document}